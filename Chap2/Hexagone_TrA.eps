%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 45 287 114 346
%%Creator:Apprenti Geometre Version 2
%%%%%%%%%%%Fichier de macros postscript écrites par Guy NOEL. %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%macrosgn est un dictionnaire contenant les définitions qui suivent%%%%%%%%%%%%%%%
%%%%%%%%%%% Pour tout renseignement: guy.noel@umh.ac.be %%%%%%%%%%%%
/macrosgn 2048 dict def  %OK
macrosgn begin	      %OK
/BBllx 10000 store /BBlly 10000 store /BBurx 0 store /BBury 0 store
/BBMessage {BB@ut exch writestring  flush} def 
/ajusterBB {eptr@ 2 div 1 add  /suplep exch store 
                     suplep add dup BBury gt {/BBury exch store}{pop} ifelse
                     suplep add dup BBurx gt {/BBurx exch store}{pop} ifelse 
                     suplep sub dup BBlly lt {/BBlly exch store}{pop} ifelse
                     suplep sub dup BBllx lt {/BBllx exch store}{pop} ifelse} def
/afficherBB { (BB.txt) (w) file /BB@ut exch store
                       (llx =) BBMessage  BBllx round str  BBMessage  ( lly =)  BBMessage BBlly round str  BBMessage  
                       ( urx =) BBMessage BBurx round str  BBMessage  ( ury =) BBMessage  BBury round str BBMessage
                       BB@ut closefile} def
                         

%% Routines générales 
/nom? {dup type str (nametype) eq} def % xx -> xx true-ou-false
/entier? {dup type str (integertype) eq} def % xx -> xx true-ou-false
/reel? {dup type str (realtype) eq} def % xx -> xx true-ou-false
/nombre? {entier? {true}{reel?} ifelse} def % xx -> xx true-ou-false
/array? {dup type str (arraytype) eq} def % xx -> xx true-ou-false
/nonemptyarray? {array? {dup length 0 gt}{false} ifelse } def % xx -> xx true-ou-false
/point? {array? 
         {dup length 2 eq 
               {dup 0 get nombre? exch pop {dup 1 get nombre? exch pop}{false}ifelse}
               {false} ifelse}
        {false}ifelse} def % % xx -> xx true-ou-false
/secteur? {array? {dup length 4 eq {dup 0 get point? exch pop {dup 1 get point? exch pop {dup 2 get point? exch pop {dup 3 get nombre? exch pop}
                                                                                                                                                                                          {false} ifelse} 
                                                                                                                                               {false} ifelse} 
                                                                                                   {false} ifelse}
                                                       {false} ifelse}
                            {false} ifelse } def 
/suitepoints?{point? {true} {array? {dup true exch {point? exch pop and} forall} {false} ifelse} ifelse} def
                        %% % % xx -> xx true-ou-false
/bipoint? {suitepoints? {dup  length 2 eq} {false} ifelse} def
/droite? {bipoint?} def
/tripoint?{suitepoints? {dup length 3 eq } {false} ifelse} def
/arccercle?{tripoint?} def
/arcellipse?{array?{dup length 4 eq {dup 0 get tripoint? exch pop} {false} ifelse}{false} ifelse} def 
/cercle? {array? {dup length 2 eq
                 {dup 0 get point? exch pop {dup 1 get nombre? exch pop}{false}ifelse}
                 {false} ifelse}
        {false}ifelse} def % % xx -> xx true-ou-false
/chemin? {array? {dup  true exch {point? exch arccercle?  exch  arcellipse?  exch pop or or  and} forall } {false} ifelse} def

/accoupler {2 assembler} bind def
/decoupler {aload pop} bind def
/desassembler{aload pop} bind def
/assembler {array astore} bind def
/str {20 string cvs } bind def
/dans? {decoupler 2 copy gt {exch} if 2 index ge 3 1 roll ge and} def  
        %% syntaxe r [a b] dans? (r, a et b réels) -> true ou false
%/multiple? {anglepolaire exch anglepolaire sub dup 0 eq exch 180 eq or} def 
        %% syntaxe p q multiple?
/alignes? {decoupler 3 array astore vectp abs epszero lt} def
/danssegment?{2 copy alignes? {2 copy decoupler abscisse exch abscisse accoupler exch abscisse exch dans?
                                                    3 1 roll  decoupler ordonnee exch ordonnee accoupler exch ordonnee exch dans? and}
                                                   {pop pop false} ifelse } def

%% Conversion des cm en points
/cm {28.35 mul} def %OK

%% Routines arithmétiques
/pgcd{2 copy gt {exch} if 1 index mod dup 0 eq {pop}{pgcd}ifelse} def 
   % calcule le pgcd de deux entiers syntaxe: a b pgcd -> d OK
/addt {/v2@ exch store /v1@ exch store 0 1 dim@nt 1 
          sub {dup v1@ exch get exch v2@ exch get add} for dim@nt array astore} def % OK

/max {2 copy lt {exch pop} {pop} ifelse} def
/min {2 copy lt {pop} {exch pop} ifelse} def

%% Fonctions trigonométriques
/cotg{dup cos exch sin div} def %OK
/tg {dup sin exch cos div} def %OK
/arccos {dup dup mul 1 exch sub sqrt exch atan} def %OK
/arcsin {dup dup mul 1 exch sub sqrt atan} def %OK
%% Conversion des radians en degrés %OK
/rad {180 mul 3.14159 div} def %OK
%% Valeur de pi
/pi 3.14159265 store
%% Valeur de e
/enep 2.718281828459045 store
/ch {dup enep exch exp exch enep exch neg exp add 2 div} def
/sh {dup enep exch exp exch enep exch neg exp sub 2 div} def
/th {dup sh exch ch div} def
/signe {dup abs dup 0 gt {div}{pop} ifelse} def
%%Cadre du dessin

/fixecadre {decoupler exch decoupler /y@t exch store /x@t exch store
            decoupler y@t sub /h@ exch store x@t sub /w@ exch store
            } def %OK

%% Fenêtre utilisateur 

/coord {w@ x@a x@i sub div /c@w exch store 
        h@ y@a y@i sub div /c@h exch store
        /M@t [c@w 0 0 c@h x@t c@w x@i mul sub y@t c@h y@i mul sub] store  
        @ngleref
}def %OK


/fixedomaine {decoupler decoupler /y@a exch store /x@a exch store 
                          decoupler /y@i exch store /x@i exch store coord} def %OK


%% Modification des instructions stroke, fill, moveto, lineto, etc
/fillstroke {gsave fill grestore stroke} def
/add2 {dup 4 1 roll add 3 1 roll add exch} def
/triplediag{dup decoupler 1 index eq {eq {1} {0} ifelse}{pop pop 0} ifelse} def %test de l'égalité des trois composantess
/fixcolor{dup length 3 eq {triplediag 1 eq {decoupler pop pop setgray}{decoupler setrgbcolor} ifelse}
                                        {decoupler setcmykcolor} ifelse} def
/stroke {c@ltrait fixcolor epaisseur  pathbbox ajusterBB end  stroke macrosgn begin} def 
/fill {c@lremp length 0 eq {end stroke macrosgn begin} {c@lremp fixcolor pathbbox ajusterBB end fill macrosgn begin} ifelse} def
/eofill {c@lremp length 0 eq {end stroke macrosgn begin} {c@lremp fixcolor end eofill macrosgn begin} ifelse} def
/show{c@lnom fixcolor dup  gsave false charpath pathbbox ajusterBB grestore end show macrosgn begin} def
/moveto{user {M@t transform} if end moveto macrosgn begin} def
/lineto{user {M@t transform} if end lineto macrosgn begin} def
/rmoveto{user {M@t dtransform} if end rmoveto macrosgn begin} def
/rlineto{user {M@t dtransform} if end rlineto macrosgn begin} def
/vr@f [1 0] store
/@ngleref {vr@f decoupler M@t dtransform exch atan /angleref exch store} def

/arc {user {/s@ns 1 store cercto@llip  @rcellip}{end arc macrosgn begin} ifelse} def
/arcn {user {/s@ns -1 store cercto@llip @rcellip}{end arcn macrosgn begin} ifelse} def
/arcto {user {/r@y exch store accoupler /p@2 exch store accoupler /p@1 exch store currentpoint accoupler /p@0 exch store
                    [p@0 p@1 p@2] vectp 0 gt {-1}{1} ifelse /s@ns exch store
                    p@2 [ p@0 p@1] perpd [ p@0 p@1] interdroites pop dup p@2 exch subp normer  r@y mulp addp [p@0 p@1] paralld
                    [p@0 p@1 p@2] bissecd interdroites pop /q@1 exch store
                    q@1 [p@0 p@1] perpd [p@0 p@1] interdroites pop /q@0 exch store
                    q@1 [p@1 p@2] perpd [p@1 p@2] interdroites pop /q@2 exch store
                    q@0 decoupler lineto q@1 decoupler r@y abs q@0 q@1 subp anglepolaire q@2 q@1 subp anglepolaire cercto@llip @rcellip 
                    q@0 decoupler q@2 decoupler}
                    {end arcto macrosgn begin} ifelse} def
/curveto {user { 3 {M@t transform 6 2 roll} repeat } if end curveto macrosgn begin} def
/updatem@t {M@t  matrix  concatmatrix /M@t exch store @ngleref} def
/tr@nsform {decoupler M@t transform accoupler} def
/translate {user {1 0 0 1 6 4 roll 6 array astore updatem@t} {end  translate macrosgn begin} ifelse} def
/rotate {user {dup cos exch sin 2 copy neg exch  0 0 6 array astore updatem@t} 
                    {end  rotate macrosgn begin} ifelse} def
/scale {user {0 0 3 2 roll 0 0 6 array astore updatem@t} {end scale macrosgn begin} ifelse} def
/concat {user {updatem@t}{end concat macrosgn begin} ifelse} def
/@mpiler {pilem@t [ M@t ] append /pilem@t exch store} def
/d@piler {pilem@t dup dup length 1 sub dup 3 1 roll get /M@t exch store 
          0 exch getinterval /pilem@t exch store } def
/gsave {user {@mpiler} if end gsave macrosgn begin} def
/grestore {user {d@piler @ngleref} if end grestore macrosgn begin} def
/currentpoint{end currentpoint macrosgn begin user {M@t itransform} if } def
/usertrue {/user true store} def
/userfalse {/user false store} def

/rogner {newpath x@i y@i moveto x@a y@i lineto x@a y@a lineto x@i y@a lineto 
                closepath clip newpath} def %OK

/debutrognage {gsave cercle? {calculcercle} if 
                          newpath dup length /n@mbr exch store 
                          dup 0 get decoupler moveto
                          1 1 n@mbr 1 sub {exch dup 3 -1 roll get decoupler lineto} for
                          closepath pop clip} def

/finrognage {grestore} def

%% Calcul de l'épaisseur du trait
/epaisseur {eptr@ setlinewidth} def %OK
/fixeepaisseurtrait {/eptr@ exch CoeffAjust mul store} def
/epaisseurtrait {eptr@} def

%% Dessin du cadre et/ou des axes
/fixeposy {/xp@sy exch store} def
/fixeposx {/yp@sx exch store} def

/cadre{[[x@i y@i][x@a y@a]] rectanglediag} def
/cadrerempli {[[x@i y@i][x@a y@a]] rectanglediagrempli} def

/origine {[0 0]} def  
/1x [1 0] store
/1y [0 1] store


/axes  {  epaisseur
          xp@sy [x@i  x@a] dans? {xp@sy y@i moveto xp@sy y@a lineto 
          stroke  xp@sy y@a moveto  90  tip}if 
          yp@sx [y@i  y@a] dans? {x@i yp@sx moveto x@a yp@sx lineto 
          stroke x@a yp@sx moveto 0 tip} if
          } def %OK

/fixelongueurmarques {/l@trait exch store} def
/traitvert {newpath moveto userfalse 0 l@trait 2 div rmoveto 0 l@trait neg rlineto stroke usertrue} def %OK
/traithor {newpath moveto userfalse l@trait 2 div 0 rmoveto l@trait neg 0 rlineto stroke usertrue} def %OK
/traitobli {newpath moveto userfalse l@trait 2 sqrt 4 div mul dup rmoveto l@trait 2 sqrt 2 div mul neg dup rlineto stroke usertrue} def %OK
/marqueverti {/traitvert marque} def
/marqueobli {/traitobli marque} def
/marquehori {/traithor marque} def
/marque {/l@trait l@trait 2 mul store 3 1 roll pointsurdroitegraduee decoupler 
         3 -1 roll cvx exec /l@trait l@trait 2 div store} def

/fixepasgraduationx {/st@x exch store} def %OK
/fixepasgraduationy {/st@y exch store} def %OK
/graduercadre{alph  x@i st@x x@a {dup y@i traitvert
                       dup str espacer exch y@i accoupler 0 talph@ 0.66 mul M@t idtransform 
                       accoupler subp etiqhorcc} for 
                       y@i st@y y@a {dup x@i exch traithor
                        dup str espacer ( ) concatener
                        exch x@i exch accoupler etiqhorg} for} def

/gradueraxey {alph  y@i st@y y@a l@bely {st@y sub} if {dup xp@sy exch traithor
                       dup 0 eq {pop}{dup str espacer ( ) concatener 
                       exch xp@sy exch accoupler etiqhorg} ifelse} for} def

/gradueraxex {alph x@i st@x x@a l@belx {st@x sub} if {dup yp@sx traitvert
                       dup str espacer exch yp@sx accoupler 0 talph@ 0.66 mul M@t idtransform 
                       accoupler subp etiqhorcc} for } def

/gradueraxes {gradueraxex gradueraxey} def


%% Concaténation de deux tableaux -- Syntaxe : t1 t2 append. Le résultat est sur la pile
/append { /s@2 exch def /s@1 exch def s@1 length dup /l@1 exch def 
              s@2 length add array /s@ exch def s@ 0 s@1 putinterval s@ l@1 s@2 putinterval s@} def %OK
/appe {1 sub {append} repeat} def %OK concatenation de plus de deux tableaux
  % syntaxe t1 t2 ... tn n appe résultat sur la pile
/ret@urner {/tab@ri exch store tab@ri length 1 sub /n@ exch  store n@  1 add array /tabf@n exch store 0 1 n@  {tab@ri n@  2 index  sub get tabf@n 3 1 roll  put} for tabf@n } def
%% Dessin d'un point 


/dotp@l{decoupler 1y exch mulp exch decoupler M@t transform accoupler dup 3 -1 roll addp 
        nc@t 3 array astore userfalse polregrempli usertrue} def
/dot{newpath decoupler /r@yon exch store decoupler M@t transform userfalse r@yon 0 360 arc fillstroke usertrue} def 
/fixetaillepoint {/diamdot exch CoeffAjust mul store} def
/fixeformepoint{/f@pt exch store} def %OK
/exef@pt {accoupler f@pt cvx exec } def %
/point{suitepoints} def
/pointpasnomme {/n@m 0 store diamdot exef@pt} def 
/pointnomme {alph /n@m 1 store dup cvx exec exch 
                dup str dup (i) exch (i) 3 concate diamchaine dup diamdot lt
                {pop diamdot}if 4 -1 roll exch exef@pt exch cvx exec etiqhorcc} def 
   
%% Dessin d'une suite de points  -- Syntaxe [[x1 y1] [x2 y2] ... [xn yn]] suitepoints

/suitepoints{nom? {pointnomme}{point? {pointpasnomme}{{suitepoints} forall}ifelse}ifelse} def

/abscisse{decoupler pop} def % p abscisse OK
/ordonnee{decoupler exch pop} def % p ordonnee OK
/rota {/@ngle exch store decoupler [ @ngle cos @ngle sin @ngle sin neg @ngle cos 0 0]
        transform accoupler} def
         % image d'un point par une rotation: syntaxe point angle rota OK
/addp {decoupler 3 2 roll decoupler exch 4 1 roll exch add 3 1 roll add exch accoupler} def
    % OK
/subp {decoupler 3 2 roll decoupler exch 4 1 roll exch sub 3 1 roll sub exch accoupler} def
    % OK
/scalp {decoupler 3 2 roll decoupler exch 4 1 roll mul 3 1 roll mul add} def
    % OK
/mulp {exch decoupler 2 index mul 3 1 roll mul exch accoupler} def % syntaxe [x y] k mulp 
   % OK
/divp {1 exch div mulp} def %OK
/vectp {decoupler 1 index subp  3 1 roll subp exch 1 index abscisse 1 index ordonnee mul 
           3 1 roll abscisse exch ordonnee mul sub} def
  % [a b c] vectp --> composante en z du produit vectoriel (a-b)^(c-b) sert à déterminer l'orientation du triplet [a b c]
/anglepolaire {decoupler  exch atan} bind def %% a  anglepolaire --> anglepol du vecteur a entre 0 et 360

/norme {decoupler dup mul exch dup mul add sqrt} def
   % OK

/normer {dup norme divp} def
   % OK
/combili {exch 4 1 roll mulp 3 1 roll exch mulp addp} def %  p1 p2 a b -> ap1+bp2
   % OK
/pointsurdroitegraduee {exch decoupler 3 -1 roll dup 1 exch sub exch combili} def % [p1 p2] t -> (1-t)p1+tp2

/isobarycentre {dup length exch origine exch {addp} forall exch  divp} def
/milieu {isobarycentre} def

%% Segments et flèches
/fixeformesegment{/fs@g exch store} def

/nametoexec{/nametype {cvx exec} def /arraytype {} def /integertype {} def /realtype {} def
            [ exch {dup type cvx exec} forall ] } def

/dep@rt {rayoncoin 0 eq cl@ not or 
                        {st@rt} 
                        {[l@st st@rt d@ux] amplitude d@ux st@rt subp normer  exch  2 div  cotg abs rayoncoin abs mul mulp 
                         st@rt addp } ifelse} def

/openpath {nametoexec aload dup  length  1 sub  /n@brs@m exch  store 
                      0 get /l@st exch store   /st@rt exch store  dup  /d@ux exch store 
                      dep@rt  desassembler moveto 
                     1 1 n@brs@m  { fs@g cvx exec} for  } def %OK

/cl@ false store

/segmentdroit {pop decoupler lineto} def
/segmentarrondi {exch  /c@in exch store /dr@p 0 store
                  dup 0 eq {/c@insuiv d@ux store pop}
                                 {n@brs@m eq {cl@ not {/dr@p 1 store} if /c@insuiv st@rt store}  {dup /c@insuiv exch store}ifelse}
                                 ifelse
                  c@in decoupler 
                  dr@p 1 eq {lineto} {c@insuiv decoupler rayoncoin arcto  4  {pop} repeat  }  ifelse 
                  } def  

/closedpath {/cl@ true store openpath  st@rt 0 fs@g cvx exec closepath /cl@ false store } def %OK
           % valable sans devoir indiquer le nombre de cotes

/suitesegments {nonemptyarray? 
                {dup 0 get point? exch pop 
                          {dup length 1 gt {newpath openpath stroke}{pop}ifelse}
                          {{suitesegments} forall} ifelse}
                {pop} ifelse}  def %OK
/suitesegmentspointes{dup nametoexec suitesegments suitepoints} def %OK
/segment {suitesegments} def %OK
/segmentpointe {suitesegmentspointes} def %OK
/suitefleches {/arraytype {} def /nametype {cvx exec} def %OK
          /integertype {pop} def /realtype {pop} def 
          dup [ exch {dup type cvx exec} forall] suitesegments 
          /integertype {} def /realtype {} def
	    [ exch {dup type cvx exec} forall]
          aload length 1 sub 2 div cvi 
          {3 copy exch 3 1 roll accoupler exch pointsurdroitegraduee 
          decoupler moveto
	    exch pop 1 index subp decoupler M@t dtransform exch atan tip} repeat pop} def
/fleche{suitefleches} def	%OK
/suiteflechespointees{dup suitefleches /arraytype {} def /nametype {} def
          /integertype {pop} def /realtype {pop} def
          [ exch {dup type cvx exec} forall] suitepoints } def %OK
/flechepointee{suiteflechespointees} def %OK

/tip {userfalse angleref add dup rotate currentpoint newpath moveto eptr@ 6 mul neg eptr@ 3 mul rlineto 
      eptr@ 1.5 mul eptr@ 3 mul neg rlineto eptr@ 1.5 mul neg eptr@ 3 mul neg rlineto
      closepath c@ltrait fixcolor end fill macrosgn begin neg rotate usertrue} def %OK

/sp@l{dup  0 get point? exch pop {closedpath}  {{sp@l} forall} ifelse }def
/polygone{suitepolygones} def %OK
/suitepolygones{newpath sp@l stroke} def
/polygonepointe{dup nametoexec polygone suitepoints} def %OK
/polygoneoriente{/arraytype {} def /nametype {cvx exec} def %OK
          /integertype {pop} def /realtype {pop} def 
          dup [ exch {dup type cvx exec} forall] polygone 
          /integertype {} def /realtype {} def 
	    [ exch {dup type cvx exec} forall]
	    aload length dup index exch 1 add 2 div cvi  	
          {3 copy exch 3 1 roll accoupler exch pointsurdroitegraduee decoupler moveto
	    exch pop 1 index subp decoupler exch atan orientationpointe add tip} repeat pop} def
/polygonepointeoriente{dup polygoneoriente /arraytype {} def /nametype {} def
          /integertype {pop} def /realtype {pop} def
          [ exch {dup type cvx exec} forall] suitepoints } def %OK
/polygonerempli{suitepolygonesremplis} def %OK
/r@mplir{ userfalse moderemplissage 2 eq 
          {gsave stroke grestore full} {gsave full grestore stroke} ifelse
          usertrue} def
/suitepolygonesremplis{newpath sp@l r@mplir}def
/polygonepointerempli{dup nametoexec polygonerempli suitepoints } def %OK
/polygoneorienterempli{/arraytype {} def /nametype {cvx exec} def %OK
          /integertype {pop} def /realtype {pop} def 
          dup [ exch {dup type cvx exec} forall] polygonerempli
          /integertype {} def /realtype {} def
	    [ exch {dup type cvx exec} forall]
	    aload length dup index exch 1 add 2 div cvi  	
          {3 copy exch 3 1 roll accoupler exch pointsurdroitegraduee decoupler moveto
	    exch pop 1 index subp decoupler exch atan tip} repeat pop} def
/polygonepointeorienterempli{dup polygoneorienterempli /arraytype {} def /nametype {} def
          /integertype {pop} def /realtype {pop} def
          [ exch {dup type cvx exec} forall] suitepoints } def %OK



%% Etoiles régulières Syntaxe: [Centre Un_sommet Nbre_de_sommets Intervalle_entre_deux_sommets] etoile...
/poletoilesommets {decoupler /int@r exch store /n@bre exch store /s@mm exch store /c@ntr exch store 
                                                360 n@bre div int@r mul /@ngrot exch store n@bre int@r pgcd  /r@p exch  store 
                                               r@p 1 eq {[ s@mm  n@bre 1 sub {dup r@t1} repeat ]}        
                                                               { [ r@p  {[ s@mm n@bre r@p idiv 1 sub  {dup r@t1} repeat ] 
                                                                  s@mm  c@ntr subp  360 n@bre div  rota c@ntr addp  /s@mm exch store } repeat ]} ifelse 
                                   }   def 	%OK

/poletoile {poletoilesommets suitepolygones} def %OK
/poletoilerempli{poletoilesommets polygonerempli} def
/poletoilepointe {dup 0 get point nametoexec poletoilesommets dup suitepolygones suitepoints } def %OK
/poletoilepointerempli {dup nametoexec poletoilesommets dup suitepolygonesremplis  suitepoints  0 get point} def  %OK

%% Polygones réguliers Syntaxe: [Centre Un_sommet Nbre_de_sommets] polreg...

/polregsommets{decoupler 3 -1 roll  (Rn) fixerosace Rn} def    %OK
/polreg {polregsommets polygone} def %OK
/polregrempli {polregsommets polygonerempli} def %OK
/polregpointe {dup 0 get point nametoexec polregsommets dup suitepolygones suitepoints} def
/polregpointerempli {dup nametoexec polregsommets dup suitepolygonesremplis  suitepoints  0 get point} def  %OK

/affectervaleurs {/suites@m exch store /suiten@ms exch store
        0 1 suites@m length 1 sub {dup suiten@ms exch get exch suites@m exch get store} for
        } def

%% Rectangles

% Rectangles définis par une diagonale. Syntaxe: [a b] rectanglediag
/rect@ngledi@g {decoupler /c@sg exch store /c@sd exch store /c@id exch store /c@ig exch store 
                [c@ig c@sg c@sd c@id] suitesegments} def
/rectanglediagsommets{decoupler decoupler /ury exch def /urx exch def decoupler/lly exch def /llx exch def
           [[llx lly] [urx lly]  [urx ury]  [llx ury]]} def %OK
/rectanglediag{rectanglediagsommets polygone} def %OK
/rectanglediagpointe{rectanglediagsommets polygonepointe} def %OK
/rectanglediagrempli{rectanglediagsommets polygonerempli} def %OK
/rectanglediagpointerempli{rectanglediagsommets polygonepointerempli} def %OK

% Rectangles définis par une médiane. Syntaxe: [[a b] largeur] rectanglemed 
/rectanglemedsommets{decoupler 2 div exch dup vecnorperp 3 -1 roll mulp exch decoupler 2 copy 
                     4 index addp exch 4 index addp 5 -3 roll exch 2 index subp 
                     3 1 roll exch subp 4 array astore} def %OK
/rectanglemed{rectanglemedsommets polygone} def %OK
/rectanglemedpointe{rectanglemedsommets polygonepointe} def %OK
/rectanglemedrempli{rectanglemedsommets polygonerempli} def %OK
/rectanglemedpointerempli{rectanglemedsommets polygonepointerempli} def %OK


/r@nd{decoupler exch /c@ntrelli exch store  dup 1x exch mulp c@ntrelli addp  /v@1 exch store  1y exch mulp c@ntrelli addp /v@2 exch store 
            /s@ns 1 store 0 360 @rcellip } def 
                                                  % centre rayon r@nd %OK

/cercleversellipse {decoupler  dup 1x exch mulp 2 index addp exch  1y exch mulp 2 index addp 3 array astore} def

/suitedisques{cercle? {newpath r@nd fillstroke}
                                   {droite? {droite}{ {suitedisques } forall } ifelse} 
                                   ifelse} def %OK
/disque{suitedisques}def
/suitecercles{cercle? {newpath r@nd stroke}
                                  {droite?  {droite} { {suitecercles} forall } ifelse} 
                                  ifelse} def %OK

/cercle{suitecercles} def

/arccercleversarcellipse {desassembler  /extr@2 exch store /@nterm exch store /v@1 exch store [v@1 @nterm] mediatrid [extr@2 @nterm] mediatrid
                                         interdroites  pop  
                                        /c@ntrelli exch store  [v@1 c@ntrelli @nterm] vectp signe /s@ns exch store 
                                          /v@2 v@1  90  c@ntrelli rotation store
                                         [ [c@ntrelli v@1 v@2]  0 [v@1 c@ntrelli extr@2] amplitude s@ns 0 lt  {360  sub} if  s@ns ]} def
                               
/arccercle {desassembler  /extr@2 exch store /@nterm exch store /v@1 exch store [v@1 @nterm] mediatrid [extr@2 @nterm] mediatrid
                                         interdroites 
                                         {/c@ntrelli exch store  [v@1 c@ntrelli @nterm] vectp signe /s@ns exch store 
                                          /v@2 v@1  90  c@ntrelli rotation store
                                          0 [v@1 c@ntrelli extr@2] amplitude s@ns 0 lt  {360  sub} if  @rcellip stroke}
                                         {@nterm [v@1 extr@2] danssegment? 
                                                                 {[v@1 extr@2] segment} 
                                                                 {v@1 [@nterm extr@2] danssegment? not {v@1 /extr@1 extr@2 store /extr@2 exch store} if
                                                                           [v@1 @nterm] demidroite [extr@2 dup 2 mulp v@1 subp] demidroite} 
                                                                 ifelse } 
                                          ifelse } def
/calculcercle {cercleversellipse calculellipse} def
/calcularccercle{arccercleversarcellipse calcularcellipse} def

/amplitude{desassembler 1 index subp anglepolaire  3 1 roll   subp anglepolaire  sub 
                      dup 0 lt {360 add} if} def

/arcsecteur {decoupler /@r1 exch store  dup amplitude @r1 0 lt {360 sub} if 2 div  /@ngrot exch store 
                   desassembler pop dup /c@ntr exch store  subp normer  @r1 abs mulp c@ntr addp    
                    dup r@t1 dup  r@t1 3 assembler} def

/arccerclesecteur {arcsecteur arccercle} def

/sectcirc@ {desassembler  /extr@2 exch store /@nterm exch store /extr@1 exch store [extr@1 @nterm] mediatrid [extr@2 @nterm] mediatrid
                                         interdroites 
                                         {/c@ exch store c@ decoupler 2 copy moveto [c@ extr@1] distance  extr@1 c@ subp anglepolaire extr@2 c@ subp anglepolaire 
                                           2 copy gt {exch} if 2 copy accoupler @nterm c@ subp anglepolaire exch dans? {arc}{arcn} ifelse closepath}  if} def            

/secteurcercle{sectcirc@ stroke} def

/secteurdisque {sectcirc@ fillstroke} def


/fixe@llipse{desassembler  /v@2 exch store /v@1 exch store  /c@ntrelli exch store } def

/@rcellip{ /bet@ exch store /@lpha exch store
                  s@ns 0 gt {bet@ @lpha lt {/bet@ bet@ 360 add store} if}{@lpha bet@ lt {/@lpha @lpha 360 add store} if} ifelse
                  @lpha p@intellipse  decoupler   {lineto} stopped  {moveto macrosgn begin } if
                  @lpha  s@ns 0 gt {1}{-1} ifelse   bet@  {p@intellipse decoupler lineto}  for} def

/calcularcellipse{desassembler /s@ns exch store   /bet@ exch store /@lpha exch store fixe@llipse
                  s@ns 0 gt {bet@ @lpha lt {/bet@ bet@ 360 add store} if}{@lpha bet@ lt {/@lpha @lpha 360 add store} if} ifelse
                  [  @lpha  s@ns 0 gt {1}{-1} ifelse   bet@  {p@intellipse }  for ]}  def

/arcellipse{arcellipsebis stroke} def
%%%% arcellipsebis est nécessaire pour chemin 
/arcellipsebis{desassembler  /s@ns exch store 3 2 roll  fixe@llipse  @rcellip} def

/tr@ceellipse {newpath fixe@llipse 0 360  /s@ns 1 store @rcellip} def

%%%%%% Point sur Ellipse  E alpha pointsurellipse %%%%%%%%%%%%
/p@intellipse {/@ngl exch store v@1 c@ntrelli subp v@2 c@ntrelli subp @ngl cos  @ngl sin  combili c@ntrelli addp} def
/pointsurellipse {exch fixe@llipse p@intellipse } def
/ellipse {tr@ceellipse stroke} def
/calculellipse {0 360  1 4 array astore  calcularcellipse} def

/suiteellipses {nonemptyarray? 
                {dup tripoint? exch pop 
                          {tr@ceellipse stroke}
                          {{suiteellipses} forall} ifelse}
                {pop} ifelse}  def 

/ellipseremplie {tr@ceellipse fillstroke} def

/suiteellipsesremplies {nonemptyarray? 
                {dup tripoint? exch pop 
                          {tr@ceellipse fillstroke}
                          {{suiteellipsesremplies} forall} ifelse}
                {pop} ifelse}  def 



/p@stip {c@ntre  [0 r@yon] addp decoupler moveto} def
/cercleorientepos {cercle p@stip 180 tip} def
/cercleorienteneg {cercle p@stip 0 tip } def
/disqueorientepos {disque p@stip 180 tip } def
/disqueorienteneg {disque p@stip 0 tip} def
/cerccp{dup distance exch decoupler pop exch accoupler} def
/cerclecp{cerccp cercle} def
/cerc3p{/trip exch store trip decoupler 3 copy accoupler mediatrid 4 1 roll accoupler mediatrid exch pop 
        interdroites {exch 1 index accoupler distance accoupler}
                           {pop trip decoupler pop accoupler} ifelse} def % [a b c] cerc3p -> [centre rayon] ou couple de deux points
/cercle3p{cerc3p cercle} def
/pointsurcerccp {/@ngl exch store decoupler 1 index subp @ngl rota addp} def 
      % [centre point] angle pointsurcerccp -> point

% Intersection d'une droite et d'un cercle
/droiteintercercle{decoupler /r@y exch store dup 2 index projection dup /pr@j exch store
                   accoupler distance dup /dist@ exch store r@y gt
                   {pop false}
                   {vecnorparall  r@y dup mul dist@ dup mul sub sqrt mulp dup pr@j addp
                    exch pr@j exch subp accoupler true} ifelse} def %OK
                % Syntaxe: droite cercle droiteintercercle -> [a1 a2] true ou false
                                      
/pointinter2drcerc{decoupler pop 1 index projection 2 mulp exch decoupler pop subp} def

/distance {decoupler subp norme} def %OK

% Intersection de deux cercles [c1 r1] et [c2 r2]
/axeradical {decoupler dup mul 3 -1 roll decoupler dup mul exch 3 1 roll exch sub
             3 copy pop accoupler distance dup dup mul exch 3 1 roll add 2 div exch div
             3 1 roll accoupler dup vecnorparall 3 -1 roll mulp exch dup 1 get 3 -1 roll
             addp exch perpd} def %OK
/intercercles {1 index axeradical exch droiteintercercle} def %OK
               % Syntaxe: [c1 r1] [c2 r2] intercercles -> [a1 a2] true ou false

                
% Syntaxe p [c1 r1] [c2 r2] pointinter2cerccerc
/pointinter2cerccerc{decoupler pop exch decoupler pop accoupler 1 index exch projection 2 mulp 
exch subp} def

%% Secteurs angulaires
%% syntaxes [b a c] secteur [[b a c] r] secteurrempli
/secteurangulaire {decoupler 1 index exch accoupler demidroite exch accoupler demidroite} def
                  

%% amplitude calcule l'amplitude (en degrés) d'un angle  orienté [a b c] secteur amplitude -> anglepolaire ba - anglepolaire bc (nombre entre 0 et 360)
%% rotation qui applique [ba] sur [bc]

%/arcn@n@ri{decoupler exch desassembler  4 copy pop 2 copy subp normer 4 -1 roll mulp addp decoupler moveto pop
 %           exch dup decoupler 6 2 roll dup 3 1 roll subp anglepolaire
  %          3 1 roll subp anglepolaire exch  arc} def
/arcnonori {arccerclesecteur} def % newpath arcn@n@ri stroke} def

%% Dans l'instruction suivante, le rayon est calculé à partir du premier point du secteur et du sommet
%% de ce secteur

/cercto@llip {5 -2 roll accoupler /c@ntrelli exch store 3 2 roll dup 0 accoupler c@ntrelli addp /v@1 exch store  0 exch accoupler c@ntrelli addp  /v@2 exch store } def

/arccerclebis {desassembler /extr@2 exch store /@nterm exch store /extr@1 exch store 
                                         [extr@1 @nterm]  mediatrid  [extr@2 @nterm] mediatrid interdroites  
                                         {/c@ exch store c@ [c@ extr@1] distance dup 1x exch mulp c@ addp exch 1y exch mulp c@ addp 3 assembler fixe@llipse
                                          extr@1 c@ subp anglepolaire extr@2 c@ subp anglepolaire  
                                          [extr@1 c@ extr@2] vectp signe /@r1 exch store [extr@1 c@ @nterm] vectp signe /@r2 exch store 
                                          [@nterm c@ extr@2] vectp signe /@r3 exch store
                                          @r1 0 ne {@r2 0 eq {@r3} {@r3 0 eq{@r2} { @r1 dup  @r2 eq { @r1 @r3 ne {neg} if}  {neg} ifelse} ifelse} ifelse}
                                                         {@r2} ifelse /s@ns exch store 
                                           @rcellip}
                                         {@nterm   [extr@1  extr@2] danssegment? 
                                                                 {extr@1 decoupler lineto extr@2 decoupler lineto} 
                                                                 {extr@1 [@nterm extr@2] danssegment? not {extr@1 /extr@1 extr@2 store /extr@2 exch store} if
                                                                           [extr@1 @nterm] demidroitebis decoupler moveto decoupler lineto 
                                                                           [extr@2 dup 2 mulp extr@1 subp] demidroitebis exch decoupler moveto decoupler lineto } 
                                                                 ifelse } 
                                          ifelse } def



/openchemin{dup length  /l@n exch store
            dup 0 get point? {decoupler moveto} 
                                       {dup 0 get  point?  {decoupler moveto arccerclebis}  {pop arcellipsebis} ifelse} ifelse
            1 1 l@n 1 sub {exch dup 3 -1 roll get point? {decoupler lineto}{dup 0 get point? {pop arccerclebis} {pop arcellipsebis} ifelse}  ifelse} for
            pop } def

/chemin {newpath openchemin  stroke } def
/lacet{newpath openchemin closepath stroke} def
/lacetrempli{newpath openchemin closepath r@mplir} def
/suitechemins  {nonemptyarray? 
                        {chemin? {chemin} {{suitechemins} forall} ifelse}
                        {pop} ifelse}  def
/suitelacets  {nonemptyarray? 
                        {chemin?  {lacet} {{suitelacets} forall} ifelse}
                        {pop} ifelse}  def 
/suitelacetsremplis  {nonemptyarray? 
                        {chemin? {lacetrempli} {{suitelacetsremplis} forall} ifelse}
                        {pop} ifelse}  def 

% syntaxe  [secteur positionpointe rayon] arcoripos ou arcorineg 
/arc@ri {desassembler /r@y exch store /c@eff exch store /s@c exch store s@c 1 get /c@ntre exch store
              newpath c@ntre s@c decoupler pop subp normer r@y mulp addp decoupler moveto
              s@c 0 get c@ntre subp anglepolaire /@1 exch store
              s@c 2 get c@ntre subp anglepolaire /@2 exch store
              @ri 0 gt {@1 @2 gt {@2 360 add /@2 exch store} if}
                           {@1 @2 lt {@2 360 sub /@2 exch store} if} ifelse
             c@ntre decoupler r@y @1 @2  @ri 0 gt {arc}{arcn} ifelse stroke
             newpath c@ntre @2 @1 sub c@eff mul @1 add /bet@ exch store bet@ dup cos exch sin accoupler r@y mulp addp
             decoupler moveto bet@ 90 @ri 0 gt {add}{sub} ifelse tip
} def

/arcoripos {/@ri 1 store arc@ri} def
/arcorineg {/@ri -1 store arc@ri} def

% flèche incurvée
% syntaxe [ [a positionpointe b] angle ] flechecourbe
	
/flechecourbe {suiteflechescourbes} def

% Suites de flèches courbes
% Syntaxe [ [ a pospointe b pospointe ... m] angle] suiteflechescourbes

/suiteflechescourbes {/arraytype {} def /nametype {cvx exec} def
           /integertype {pop} def /realtype {pop} def
           decoupler /@ng exch store /s@ite exch store
           @ng 180 gt {/@ri 1 store} {/@ri -1 store} ifelse 
           @ng 180 eq {pop}
                               {@ng 0 eq @ng 360 eq or 
                                           {suitefleches} 
                                           {s@ite length 3 sub 2 div /n@bre exch store 
                                                  0 1 n@bre {2 mul /i@ exch store s@ite i@ get dup type cvx exec 
                                                  s@ite  i@ 1 add get /p@s exch store 
                                                  s@ite  i@ 2 add get dup type cvx exec 
			  2 copy exch subp @ng rota origine accoupler 
                                                  2 index exch perpd 3 1 roll 2 copy accoupler mediatrid
                                                  4 -1 roll interdroites pop exch 3 array astore
                                                 dup dup 1 get exch 0 get accoupler distance 
			 p@s exch 3 array astore arc@ri } for 
                                              }ifelse}ifelse} def 


/suiteflechescourbespointees{dup suiteflechescourbes 
           /arraytype {} def /nametype {} def
           /integertype {pop} def /realtype {pop} def
           decoupler pop 
          [ exch {dup type cvx exec} forall] suitepoints } def %OK
/flechecourbepointee{suiteflechescourbespointees} def %OK

/boucle % Syntaxe [a b] boucle a: origine de la boucle, b "deuxième sommet"
   {decoupler tr@nsform /@xtre exch store tr@nsform /@ri exch store userfalse
              @xtre @ri subp 0.5 mulp dup 45 rota /c@ntr1 exch store 
              90 rota /c@ntr2 exch store
              newpath @ri decoupler moveto @ri c@ntr1 addp decoupler 
              @xtre c@ntr2 addp decoupler @xtre decoupler curveto
              @xtre c@ntr2 subp decoupler @ri c@ntr1 -90 rota addp decoupler 
              @ri decoupler curveto closepath stroke } def
%            @xtre dup decoupler moveto usertrue
%            @ri subp anglepolaire 80 add tip} def

/suiteboucles {nonemptyarray? 
                {dup 0 get point? exch pop 
                                               {boucle}{{suiteboucles} forall} ifelse}
                {pop} ifelse}  def %OK


%% Couleurs

/rouge [1 0 0] store
/vert [0 1 0] store
/bleu [0 0 1] store
/jaune [0 0 1 0] store
/cyan [1 0 0 0] store
/magenta [0 1 0 0] store
/noir [0 0 0] store
/blanc [1 1 1] store
/gris [0.7 0.7 0.7] store
/fixecouleurtrait {/c@ltrait exch store} def
/fixecouleurfond {/c@lremp exch store} def
/fixecouleurtexte {/c@lnom exch store} def
/fixecouleurs {dup dup fixecouleurtrait fixecouleurfond fixecouleurtexte} def
/full{moderemplissage 1 eq {eofill} {fill} ifelse} def
/fixemoderemplissage{/moderemplissage exch store} def
/couleurtrait {c@ltrait} def
/couleurfond {c@lremp} def
/couleurtexte {c@lnom} def
/sauvecouleurs {couleurtrait couleurfond couleurtexte 3 array astore /c@uleurs exch store} def
/restaurecouleurs {c@uleurs decoupler fixecouleurtexte fixecouleurfond fixecouleurtrait} def

/symb {/carsymb 1 string store carsymb exch 0 exch put carsymb} def %OK crée une chaîne d'un seul 
% caractère à partir du code de celui-ci. syntaxe code symb -> résultat sur la pile
 
/diamchaine {alph newpath 0 0 moveto true charpath pathbbox 3 -1 roll sub abs 
             3 1 roll sub abs 2 copy lt {exch pop}{pop} ifelse 2 div} def

%% Résolution de l'équation du premier degré a+bx=c Syntaxe a b c resequ@

/resequ@{3 2 roll sub exch div} def


%% Choix du style de trait (tirete, plein, pointillé)
/traitplein {[] 0 setdash} def
/traittirete {[4] 0 setdash} def
/traitpointille {[2] 0 setdash} def

/droiteintercadre {decoupler 2 copy abscisse exch abscisse 
         1 index eq {exch pop y@i accoupler exch abscisse y@a accoupler}
                    {pop 2 copy ordonnee exch ordonnee 1 index eq
                        {exch pop x@i exch accoupler exch ordonnee x@a exch accoupler}         
                        {pop 1 index subp 2 copy
		   2 copy abscisse exch abscisse exch 2 copy 
                                  x@i resequ@ /t@1 exch store x@a resequ@ /t@2 exch store %t@1 bord gauche, t@2 bord droit
                                  ordonnee exch ordonnee exch 2 copy                                    %t@3 bord inf t@4 bord sup
                                  y@i resequ@ /t@3 exch store y@a resequ@ /t@4 exch store
                          t@1 t@2 gt {/t@1 t@2 /t@2 t@1 store store} if
                          t@1 t@3 gt {/t@1 t@3 /t@3 t@1 store store} if
                          t@1 t@4 gt {/t@1 t@4 /t@4 t@1 store store} if                          
                          t@1 t@3 gt {/t@1 t@3 /t@3 t@1 store store} if
                          t@2 t@3 gt {/t@2 t@3 /t@3 t@2 store store} if
                          t@2 t@4 gt {/t@2 t@4 /t@4 t@2 store store} if
                          t@3 t@4 gt {/t@3 t@4 /t@4 t@3 store store} if
                          2 copy t@2 mulp addp 3 1 roll t@3 mulp addp} ifelse
                   } ifelse
          2 copy dansdomaine? {dansdomaine? {accoupler true} {pop pop false} ifelse}
                              {pop pop pop false} ifelse
          }def % OK

/droite {droiteintercadre  {segment} if  } def

/demidroite {dup  decoupler /interm@ exch store /@ri exch store droiteintercadre 
                             {dup 0 get @ri accoupler interm@ exch danssegment?  
                              {0 get } {1 get} ifelse @ri accoupler segment} if} def 

/demidroitebis {dup  decoupler /interm@ exch store /@ri exch store droiteintercadre 
                             {dup 0 get @ri accoupler interm@ exch danssegment?  
                              {0 get } {1 get} ifelse @ri } if} def 
                        
/interdroites {2 copy  vecnorperp exch vecnorparall scalp abs epszero lt
                   {pop pop false} 
                   {dup vecnorperp  dup 3 index decoupler  exch subp scalp 
                    3 1 roll exch decoupler  pop 3 index decoupler pop subp scalp
                    exch div dup /t@ exch store pointsurdroitegraduee true} ifelse} def
          % Syntaxe [p1 p2] [p3 p4] interdroites --> false ou pt true

/droiteintersegment {exch interdroites 
                         {t@ [0 1] dans? {true}{pop false} ifelse } 
                         {false} ifelse}def

          % Syntaxe [p1 p2] [p3 p4] droiteintersegment --> false ou pt true

/intersegments {2 copy droiteintersegment 
                   {pop exch droiteintersegment}
                   {pop pop false}          
                   ifelse} def

          % Syntaxe [p1 p2] [p3 p4] intersegments --> false ou pt true

/perpd {vecnorperp 1 index addp accoupler} def % syntaxe p1 [p2 p3] perpd
    % OK

/droiteperp{perpd droite} def
    % OK

/inclid {decoupler exch subp exch rota exch dup 3 1 roll addp accoupler} def
    % syntaxe p1 angle [p2 p3] inclid

/droiteincli {inclid droite} def

/vecnorperp {decoupler subp decoupler neg exch accoupler normer} def 
    %syntaxe [p1 p2] vecnorperp fournit une vecteur normé perpendiculaire à la droite [p1 p2] OK

/projection {dup 3 1 roll vecnorperp 1 index addp accoupler interdroites pop} def 
    %syntaxe p1 [p2 p3] projection --> proj

/paralld {decoupler exch subp 1 index addp accoupler} def %syntaxe p1 [p2 p3] paralld
    % OK
/droiteparall{paralld droite} def
    % OK
/droitemediatrice {mediatrid droite} def
    % OK
/mediatrid {dup  milieu exch perpd } def
    %OK
/droitebissectrice {bissecd droite} def
    %syntaxe [a b c] bissectrice %OK

/bissecd {decoupler 1 index subp normer 1 index addp 3 1 roll exch 1 index subp normer addp accoupler mediatrid} def             
    % OK


/vecnorparall{decoupler subp normer} def 
    %syntaxe [a b] vecnorparall fournit un vecteur normé parallèle à [a b] OK


/equerre {aload pop /r@y exch store  aload pop exch /c@ntre exch store
          c@ntre subp normer r@y mulp exch c@ntre subp normer r@y mulp 2 copy addp exch
          3 array astore [ exch {c@ntre addp} forall ] suitesegments} def

%%% Courbes

%% Calcul et/ou Dessin de l'image d'un point ou d'une courbe par une machine (transformation)

%Syntaxe /pointmobile t1 step t2 calculcourbe

/pointmobilelieu{dup gene1 exch gene2 interdroites } def

/pointmobileparam{dup fx exch fy accoupler true} def

/pointmobilepolaire{dup fr exch rad accoupler polverscar true} def

/pointmobilediff{dr@pp 0 eq {pop pt0 dup /pt@ exch store /dr@pp 1 store}
     {/t@ exch store pt@ t@ fx pt@ t@ fy accoupler ss mulp /k@1 exch store
      pt@ k@1 2 divp addp t@ ss 2 div add 2 copy fx 3 1 roll fy accoupler ss mulp /k@2 exch store
      pt@ k@2 2 divp addp t@ ss 2 div add 2 copy fx 3 1 roll fy accoupler ss mulp /k@3 exch store
      pt@ k@3 addp t@ ss add 2 copy fx 3 1 roll fy accoupler ss mulp /k@4 exch store
      k@1 k@2 2 mulp addp k@3 2 mulp addp k@4 addp 6 divp
      pt@ addp dup /pt@ exch store} ifelse true} def

/pointmobilefonction{dup f accoupler true} def

/calculcourbe {/dr@p 0 store 1 index /ss exch store /dr@pp 0 store
    4 -1 roll /p@tm@bile exch store [ [ 5 2 roll  {p@tm@bile cvx exec 
       {dr@p 1 eq {/t@mp exch store dup t@mp subp norme epsmax gt {][ t@mp }{t@mp}ifelse}
                         {/dr@p 1 store} 
                         ifelse}  
       {dr@p 1 eq {][/dr@p 0 store} if}  ifelse}  for 
       dr@p 1 eq {]}{pop} ifelse ] dup length 1 eq {decoupler} if} def  

/droiteintercourbe {exch /dr@ite exch store
                 nonemptyarray? 
                {dup 0 get point? exch pop 
                     {/c@urbe exch store c@urbe length /n@ exch store n@ 1 gt
                      {[ 0 1 n@ 2 sub {dup c@urbe exch get exch 1 add c@urbe exch get accoupler 
                                    dr@ite exch droiteintersegment pop}for ]}if }
                     {[ exch {dr@ite exch droiteintercourbe} forall ]} ifelse}
                {pop} ifelse} def %OK

%% syntaxe [a b] [[p1 p2....][p'1 p'2 ...] ....] droiteintercourbe

%% Moyenne géométrique de deux longueurs |o a| et |o b|, données par les deux points a et b

/moygeo {norme exch norme mul sqrt} def


/dessincourbe {calculcourbe suitesegments} def

/conique5p{[/a@ /b@ /c@ /d@ /e@] exch affectervaleurs
/T@ [d@ e@] store /U@ [b@ c@] store  /V@ [c@ d@] store conique} def

/conique4p1t{[/a@ /b@ /c@ /d@  /T@] exch affectervaleurs
/e@ d@ store  /U@ [b@ c@] store  /V@ [c@ d@] store conique} def

/conique3p2t{[/a@ /b@ /d@  /U@ /T@ ] exch affectervaleurs
/c@ b@ store /e@ d@ store  /V@ [c@ d@] store  conique} def

/hyperbolec2d{[/c@ /b@ /a@] exch affectervaleurs [b@ [c@  a@ b@ addp c@ subp][c@ b@ c@ addp a@ subp]]
                   hyperbole1p2a} def

/hyperbole3p1a{[/a@ /b@ /c@  /A@ ] exch affectervaleurs
[a@ b@] A@  interdroites pop /u@ exch store 
/gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store} def
/gene2{pop gen c@ A@ paralld  interdroites {/w@ exch store /dr@2 1 store} {/dr@2 0 store} ifelse
dr@2 1 eq {/D@ [u@ w@] store} {/D@ A@ store} ifelse
[b@ c@] D@ interdroites {A@ paralld} {A@} ifelse} def
/pointmobilelieu 0 1 180 calculcourbe} def

/parabole3pda{[/a@ /b@ /c@  /A@] exch affectervaleurs
/gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store} def
/gene2{pop gen c@ A@ paralld interdroites {/w@ exch store /dr@2 1 store} {/dr@2 0 store} ifelse
dr@2 1 eq  {/D@ w@ [a@ b@] paralld store} {/D@ [b@ c@] store} ifelse
[b@ c@] D@ interdroites {A@ paralld}{gen}ifelse} def
/pointmobilelieu 0 1 180 calculcourbe} def


/parabole4pter{a@ s@ subp dup b@ s@ subp moygeo 
                             exch normer exch mulp 
                            c@ s@ subp dup d@ s@ subp moygeo 
                             exch normer exch mulp 
                             2 copy addp origine accoupler /A@ exch store [a@ b@ c@ A@] parabole3pda
                             subp origine accoupler /A@ exch store [a@ b@ c@ A@] parabole3pda} def
/parabole4pb {[/a@ /b@ /c@  /d@] exch affectervaleurs
dr@1 2 lt {[a@ b@] [c@ d@] interdroites {/s@ exch store parabole4pter}
                                                                            {/dr@1 dr@1 1 add store [a@ c@ b@ d@] parabole4pb} 
                                                                            ifelse} if} def
/parabole4p{ /dr@1 0 store parabole4pb} def

/hyperbole1p2a{[/a@ /B@ /A@ ] exch affectervaleurs
A@ B@ interdroites {pop 
 a@ B@ paralld  A@  interdroites pop /u@ exch store 
/gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store } def
/gene2{pop  u@ gen paralld  B@ interdroites {A@ paralld} {gen} ifelse } def
/pointmobilelieu 0 1 180 calculcourbe } if} def

/conique {[a@ b@] T@  interdroites {/u@ exch store /dr@1 1 store } {/dr@1 0 store } ifelse
                  /gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store} def
                  /gene2{pop gen V@ interdroites {/w@ exch store /dr@2 1 store } {/dr@2 0 store } ifelse
                  dr@1 1 eq dr@2 1 eq and {/D@ [u@ w@] store} if
                  dr@1 0 eq dr@2 1 eq and {/D@ w@ T@ paralld store } if
                  dr@1 1 eq dr@2 0 eq and {/D@ u@ V@ paralld store} if
                  dr@1 0 eq dr@2 0 eq and {e@ U@ paralld} {U@ D@ interdroites {e@ accoupler}{e@ [b@ c@] paralld}ifelse}  ifelse} def
                  /pointmobilelieu 0 1 180 calculcourbe} def

/batonnets {dup nonemptyarray? 
                {0 get point? exch pop {{dup point dup abscisse 0 accoupler accoupler segment} forall}
                                 {{batonnets} forall} ifelse}
                {pop} ifelse} def %OK

/barres {/l@r exch store dup nonemptyarray? 
                {0 get point? exch pop {{dup abscisse 0 accoupler accoupler l@r accoupler 
                                         rectanglemedrempli} forall}
                                 {{l@r barres} forall} ifelse}
                {pop} ifelse} def %OK

/barresmultiples {/l@r exch store /c@uleurs exch store c@uleurs length /n@ exch store
                  {decoupler /s@m exch store /c@ exch store  
                   0 1 n@ 1 sub {/k@ exch store l@r k@ mul c@ add dup s@m k@ get accoupler 
                                 exch 0 accoupler accoupler l@r accoupler 
                                 c@uleurs k@ get fixecouleurfond rectanglemedrempli} for} forall
                  } def %OK

/histogramme {/ord@ exch store dup length /n@ exch store /l@rg exch store /deb@ exch store 
              0 1 n@ 1 sub {/k@ exch store [deb@ 0] deb@ l@rg k@ get add dup /deb@ exch store 
                            ord@ k@ get accoupler accoupler rectanglediag } for } def

/histogrammerempli {/ord@ exch store dup length /n@ exch store /l@rg exch store /deb@ exch store 
              0 1 n@ 1 sub {/k@ exch store [deb@ 0] deb@ l@rg k@ get add dup /deb@ exch store 
                            ord@ k@ get accoupler accoupler rectanglediagrempli } for } def

/escalier {/ord@ exch store dup length /n@ exch store /l@rg exch store /deb@ exch store 
              0 1 n@ 1 sub {/k@ exch store [deb@ ord@ k@ get] [deb@ l@rg k@ get add dup /deb@ exch store 
                            ord@ k@ get] accoupler segment} for } def


%% Routines "tortue"

/fixecaptortue{/captortue exch store}def
/fixepositortue{dup crayon 1 eq {positortue exch accoupler segment}{pop} ifelse
                /positortue exch store}def
/ga{captortue add /captortue exch store}def
/dr{neg ga }def
/av{[captortue dup cos exch sin] exch mulp positortue addp fixepositortue}def
/re{neg av}def
/lc{/crayon 0 store}def 
/bc{/crayon 1 store}def
/vers{positortue subp anglepolaire} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Valeurs par défaut %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/epsmax 1 store
/crayon 1 store
/captortue 90 store
/positortue [0 0] store
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Procédures globales %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/dessiner {/dr@pdessin true store /N 0 store {1 index N get exch cvx exec /N N 1 add store} forall pop  /r@pp 1 store /@nglerot 0 store baisserdr@p } def
/baisserdr@p {/dr@prot false store  /dr@phom false store /dr@paffi false store /dr@pdessin false store /dr@psym false store} def
/suitedessins {/dr@pdessin true store {instructions dessiner} forall baisserdr@p} def
%%% Transformations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rotations syntaxe: suitepoints angle centre rotation
%%% Translations: suitepoints vecteur translation 

%%Un objet rotation est un triplet [angle centre /rotation]
%%Un groupe de rotations engendré par une rotation est un triplet [angle centre /groupederotations]
 

/r@t1{nombre? not {point? {c@ntr subp @ngrot rota c@ntr addp} {array? {[ exch  {r@t1} forall]} if} ifelse} if} def
/rotation{/dr@prot true store /c@ntr exch store /@ngrot exch store r@t1 /@ngrot 0 store } def

/groupederotations{/c@ntr exch store  /@ngrot exch store 
                [exch 360 dup @ngrot pgcd idiv  1 sub {dup r@t1} repeat ]
                } def 
/appliquer {aload pop cvx exec} def
%% syntaxe "suitepoints transfo appliquer" ou "suitepoints groupe appliquer"

%%%%%%%%% Rosaces    %Syntaxe :  Motif n centre Rn  Motif n centre droite Rnm
/ros@ce { [ exch it@r 1 sub {dup @ng c@ntr rotation} repeat ] typ@ (Rnm) eq {[ exch {decoupler} forall]} if } def
/fixerosace{ /typ@ exch store  /c@ntr exch store /it@r exch store /@ng 360 it@r div store typ@ (Rnm) eq {/dr@ite exch store} if } def
/Rn {/typ@ (Rn) store ros@ce} def
/Rnm {/typ@ (Rnm) store dup sym@ accoupler ros@ce} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Un objet translation est un couple [vecteur /translation]
%% Un groupe de translations est un couple [vecteur /groupedetranslations]

/tr@ns1 {nombre? not {point? {v@ct addp} {array? {[ exch {tr@ns1} forall ] } if}  ifelse }  if} def
/translation {/v@ct exch store tr@ns1} def
/demi@rbite {  {dup tr@ns1 dup dansdomaine? not {pop exit} if } loop } def
/groupedetranslations{/v@ct exch store /m@tif exch store [ m@tif demi@rbite /v@ct v@ct -1 mulp store 
 m@tif demi@rbite  ]} def
/dansdomaine? {nombre? {pop false} { point? {dup abscisse [x@i x@a] dans? exch ordonnee [y@i y@a] dans? and}
                                                              { array? {false exch {dansdomaine? or} forall }{pop false} ifelse } ifelse} ifelse  } def 
         %% syntaxe xx dansdomaine? ---> true ou false
         %% une suite de points est dans le domaine dès qu'un point de la suite est dans le domaine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Un objet homothetie est un triplet [rapport centre  /homothetie]
%% Un groupe d'homotheties est un triplet [rapport centre  /orbitehomothetie]

/h@m1{point? {c@ntr subp r@pp mulp c@ntr addp}
                        {array? {cercle? {decoupler r@pp mul exch h@m1 exch accoupler} {[exch {h@m1} forall] }  ifelse}  if } 
                        ifelse } def
/homothetie{/dr@phom true store /c@ntr exch store /r@pp exch store h@m1} def


/grouped'homotheties{/c@ntr exch store /r@pp exch store /r@ppn r@pp abs store
               [ exch  { dup h@m1 /r@ppn r@ppn r@pp abs mul store dup dansdomaine? not r@ppn abs 0.001 le or {exit} if} loop 
                /r@pp 1 r@pp div store /r@ppn r@pp abs  store  { dup h@m1 /r@ppn r@ppn  r@pp abs mul store dup dansdomaine? not r@ppn 0.001 le or {exit} if} loop]
               } def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Un objet similitude est un quadruplet [rapport angle centre  /similitude]
%% Un groupe de similitudes est un triplet [rapport angle centre  /orbitesimilitude]

/s@m1{point? {c@ntr subp r@pp mulp  @ng rota c@ntr addp}
                       {array? {cercle? {decoupler r@pp mul exch s@m1 exch accoupler} {[exch {s@m1} forall]} ifelse} if }
                       ifelse } def
/similitude{/dr@phom true store /dr@prot true store /c@ntr exch store /@ng exch store /r@pp exch store s@m1} def

/groupedesimilitudes{/c@ntr exch store /@ng exch store /r@pp exch store  /r@ppn r@pp abs store
               [ exch  { dup s@m1 /r@ppn r@ppn r@pp abs mul store dup dansdomaine? not  r@ppn abs 0.001 le or {exit} if} loop 
                /r@pp 1 r@pp div store /r@ppn r@pp abs  store /@ng @ng neg store  
               { dup s@m1 /r@ppn r@ppn  r@pp abs mul store dup dansdomaine? not  r@ppn 0.001 le or {exit} if} loop]
               } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Un objet symétrie axiale est un couple [droite  /symetrie]
/sym@{nombre? {} {point? {dup dr@ite perpd dr@ite interdroites pop 2 mulp exch subp}
                                                                    {array? {[exch {sym@} forall] } if } ifelse } ifelse } def
/symetrie{/dr@psym true store /dr@ite exch store  sym@ } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Un objet inversion est un couple [cercle  /inversion]
/inv@{nombre? {}
           {point? {c@rcle decoupler dup mul 3 1 roll exch accoupler dup distance dup mul exch 3 1 roll div pointsurdroitegraduee}
                       {[ exch {inv@} forall]}ifelse}ifelse } def
/inversion{/c@rcle exch store  inv@} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Un objet affinite est un couple [matrice /affinite]
/@ffi {point? {decoupler m@trice transform accoupler}
                     {array? {[exch {@ffi} forall]} if } ifelse} def
/affinite {/dr@paffi true store /m@trice exch store  @ffi} def
end
%%EndProlog
/debut {
/CoeffAjust 1 store
macrosgn begin /saveobj save store
/pilem@t [] store
usertrue
[[1 cm 1 cm ][11 cm 11 cm]] fixecadre
0 fixeposy
0 fixeposx
1 fixepasgraduationx
1 fixepasgraduationy
/l@belx false store
/l@bely false store
/orientationpointe 0 store
5 fixelongueurmarques
/dot fixeformepoint
/segmentdroit fixeformesegment
/rayoncoin 0 store
noir fixecouleurtrait
noir fixecouleurfond
noir fixecouleurtexte
0 fixemoderemplissage
1.2 fixetaillepoint
1 fixeepaisseurtrait
/epszero 0.000003 store
/epsmax 1 store
/crayon 1 store
/captortue 90 store
/positortue [0 0] store
baisserdr@p
/@ng 0 store
} def
/fin {saveobj restore end} def
%%%%%%%%%%%%%%Données spécifiques à la figure %%%%%%%%%%%%%%%%%
debut
[[2 cm 2 cm][12 cm 12 cm]] fixecadre
[[-5 -5][5 5]] fixedomaine
/p2 [-4.7 3.34]   store
/p3 [-3.7 3.34]   store
/p4 [-3.2 4.206025]   store
/p5 [-3.7 5.072051]   store
/p6 [-4.7 5.072051]   store
/p7 [-5.2 4.206025]   store
/p9 [-4.7 3.34]   store
/p10 [-3.7 3.34]   store
/p11 [-4.2 4.206025]   store
/p13 [-5.2 4.206025]   store
/p14 [-4.7 3.34]   store
/p15 [-4.2 4.206025]   store
/p17 [-3.7 3.34]   store
/p18 [-3.2 4.206025]   store
/p19 [-4.2 4.206025]   store
/p21 [-5.2 4.206025]   store
/p22 [-4.2 4.206025]   store
/p23 [-4.7 5.07205]   store
/p25 [-3.7 5.072051]   store
/p26 [-4.69999 5.076497]   store
/p27 [-4.203845 4.208257]   store
/p29 [-4.2 4.206025]   store
/p30 [-3.2 4.206025]   store
/p31 [-3.7 5.07205]   store
[0 0 0 0 ] fixecouleurfond
1 fixeepaisseurtrait
[ p2 p3 p4 p5 p6 p7 ] polygone
[0 0 1 0 ] fixecouleurfond
[ p9 p10 p11 ] polygonerempli
[ p13 p14 p15 ] polygonerempli
[ p17 p18 p19 ] polygonerempli
[ p21 p22 p23 ] polygonerempli
[ p25 p26 p27 ] polygonerempli
[ p29 p30 p31 ] polygonerempli

fin
